const imaps = require('imap-simple');
const { simpleParser } = require('mailparser');
const { emailConfig } = require('../config/email');
const prisma = require('../config/database');
const { parseVendorProposal, generateProposalSummary } = require('./aiService');

let isPolling = false;
let pollInterval = null;

// Configure IMAP connection
const imapConfig = {
  imap: {
    user: emailConfig.user,
    password: emailConfig.password,
    host: emailConfig.imap.host,
    port: emailConfig.imap.port,
    tls: true,
    tlsOptions: { rejectUnauthorized: false },
    authTimeout: 10000,
  },
};

// Extract RFP ID from email subject
function extractRFPId(subject) {
  const match = subject.match(/\[RFP-([a-f0-9-]+)\]/i);
  return match ? match[1] : null;
}

// Process a single email
async function processEmail(connection, message) {
  try {
    // Get all parts to find the best one
    let bodyPart = null;
    let bodyText = '';
    
    // First, try to parse the HEADER to get subject and from
    const headerPart = message.parts.find(part => part.which === 'HEADER');
    let subject = '';
    let from = '';
    
    if (headerPart) {
      try {
        const headerData = await connection.getPartData(message, headerPart);
        const headerParsed = await simpleParser(headerData);
        subject = headerParsed.subject || '';
        from = headerParsed.from?.value[0]?.address || '';
      } catch (error) {
        console.log('‚ö†Ô∏è Could not parse header');
      }
    }
    
    // Try to get TEXT part
    const textPart = message.parts.find(part => part.which === 'TEXT');
    if (textPart) {
      try {
        const textData = await connection.getPartData(message, textPart);
        const textParsed = await simpleParser(textData);
        bodyText = textParsed.text || textParsed.html || '';
        if (!subject) subject = textParsed.subject || '';
        if (!from) from = textParsed.from?.value[0]?.address || '';
      } catch (error) {
        console.log('‚ö†Ô∏è Could not parse TEXT part');
      }
    }
    
    // If no body text yet, try empty part (full message)
    if (!bodyText) {
      const emptyPart = message.parts.find(part => part.which === '');
      if (emptyPart) {
        try {
          const fullData = await connection.getPartData(message, emptyPart);
          const fullParsed = await simpleParser(fullData);
          bodyText = fullParsed.text || fullParsed.html || '';
          if (!subject) subject = fullParsed.subject || '';
          if (!from) from = fullParsed.from?.value[0]?.address || '';
        } catch (error) {
          console.log('‚ö†Ô∏è Could not parse full message');
        }
      }
    }
    
    if (!bodyText) {
      console.log('‚ö†Ô∏è No body text found, skipping...');
      return;
    }
    
    console.log(`\nüìß New email from: ${from}`);
    console.log(`Subject: ${subject}`);

    // Extract RFP ID from subject
    const rfpId = extractRFPId(subject);
    if (!rfpId) {
      console.log('‚ùå No RFP ID found in subject, skipping...');
      return;
    }

    console.log(`‚úÖ Found RFP ID: ${rfpId}`);

    // Find the RFP
    const rfp = await prisma.rFP.findUnique({
      where: { id: rfpId },
      include: { rfpVendors: true },
    });

    if (!rfp) {
      console.log(`‚ùå RFP not found: ${rfpId}`);
      return;
    }

    // Find the vendor by email
    const vendor = await prisma.vendor.findUnique({
      where: { email: from },
    });

    if (!vendor) {
      console.log(`‚ùå Vendor not found with email: ${from}`);
      return;
    }

    // Check if proposal already exists
    const existingProposal = await prisma.proposal.findFirst({
      where: {
        rfpId: rfpId,
        vendorId: vendor.id,
      },
    });

    if (existingProposal) {
      console.log(`‚ö†Ô∏è Proposal already exists for this vendor and RFP`);
      return;
    }

    console.log(`ü§ñ Parsing proposal with AI...`);

    // Parse the email content with AI
    const parsedData = await parseVendorProposal(bodyText, {
      title: rfp.title,
      description: rfp.description,
      budget: rfp.budget,
      requirements: rfp.requirements,
    });

    console.log('üìä Parsed data:', JSON.stringify(parsedData, null, 2));

    // Create the proposal
    const proposal = await prisma.proposal.create({
      data: {
        rfpId: rfpId,
        vendorId: vendor.id,
        rawEmailContent: bodyText,
        parsedData: parsedData,
        totalPrice: parsedData.totalPrice,
        deliveryTime: parsedData.deliveryTime,
        terms: parsedData.terms,
        status: 'received',
      },
    });

    console.log(`‚úÖ Proposal created: ${proposal.id}`);

    // Generate AI summary and score
    try {
      const summary = await generateProposalSummary(
        {
          totalPrice: parsedData.totalPrice,
          deliveryTime: parsedData.deliveryTime,
          parsedData: parsedData,
        },
        rfp
      );

      await prisma.proposal.update({
        where: { id: proposal.id },
        data: {
          score: summary.score,
          aiSummary: summary.summary,
        },
      });

      console.log(`üìù AI Summary generated with score: ${summary.score}`);
    } catch (error) {
      console.error('Error generating summary:', error);
    }

    // Mark email as seen
    try {
      await connection.addFlags(message.attributes.uid, ['\\Seen']);
    } catch (error) {
      console.log('‚ö†Ô∏è Could not mark email as seen');
    }
  } catch (error) {
    // Only log if it's not an IMAP parsing error
    if (!error.message?.includes('Could not parse command')) {
      console.error('Error processing email:', error.message);
    }
  }
}

// Poll inbox for new emails
async function pollInbox() {
  if (isPolling) {
    console.log('‚è≠Ô∏è Already polling, skipping...');
    return;
  }

  isPolling = true;

  try {
    console.log('üì¨ Checking for new emails...');

    const connection = await imaps.connect(imapConfig);
    await connection.openBox('INBOX');

    // Search for unseen emails
    const searchCriteria = ['UNSEEN'];
    const fetchOptions = {
      bodies: ['HEADER', 'TEXT', ''],
      struct: true,
      markSeen: false,
    };

    const messages = await connection.search(searchCriteria, fetchOptions);

    if (messages.length === 0) {
      console.log('üì≠ No new emails');
    } else {
      console.log(`üì¨ Found ${messages.length} new email(s)`);

      for (const message of messages) {
        await processEmail(connection, message);
      }
    }

    connection.end();
  } catch (error) {
    console.error('‚ùå Error polling inbox:', error.message);
  } finally {
    isPolling = false;
  }
}

// Start email polling
function startEmailPolling(intervalMs = 30000) {
  if (pollInterval) {
    console.log('Email polling already started');
    return;
  }

  console.log(`üöÄ Starting email polling (every ${intervalMs / 1000}s)`);
  
  // Poll immediately
  pollInbox();
  
  // Then poll at intervals
  pollInterval = setInterval(pollInbox, intervalMs);
}

// Stop email polling
function stopEmailPolling() {
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
    console.log('Email polling stopped');
  }
}

module.exports = {
  startEmailPolling,
  stopEmailPolling,
  pollInbox,
};
